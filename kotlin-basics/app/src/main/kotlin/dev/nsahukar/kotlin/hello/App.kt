/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package dev.nsahukar.kotlin.hello

import java.nio.file.Path
import java.nio.file.Paths
import java.nio.file.Files
import java.io.InputStream
import java.io.IOException
import java.util.Date
import java.io.File

class App {
    val greeting: String
        get() {
            return "Hello from Gradle!"
        }
}

// Exception handling
fun readFile(path: Path): Unit {
    var input: InputStream? = null
    try {
        input = Files.newInputStream(path)
        var byte = input.read()
        while (byte != -1) {
            println(byte)
            byte = input.read()
        }
    } catch (e: IOException) {
        println("Error reading from file. ${e.message}")
        e.printStackTrace()
    } finally {
        input?.close()
    }
}

fun readExceptionalFile() {
    println("About to throw up reading a file...")
    throw IOException()
}

fun readMediocreFile() {
    println("Reading mediocre file...")
}

fun isString(any: Any): Boolean {
    return if (any is String) true else false
}

fun printStringLength(any: Any) {
    if (any is String) {
        println("$any's length: ${any.length}")
    }
}

fun isEmptyString(any: Any): Boolean {
    return any is String && any.length == 0
}

fun isNotStringOrEmpty(any: Any): Boolean {
    return any !is String || any.length == 0
}

fun whatBinaryDigit(x: Int) {
    when(x) {
        0 -> println("Zero")
        1 -> println("One")
        else -> println("Not a binary digit!")
    }
}

fun isBinary(x: Int): Boolean {
    return when(x) {
        0, 1 -> true
        else -> false
    }
}

fun isAbs(x: Int): Boolean {
    return when(x) {
        Math.abs(x) -> true
        else -> false
    }
}

fun isSingleDigit(x: Int): Boolean {
    return when(x) {
        in -9..9 -> true
        else -> false
    }
}

fun isDieNumber(x: Int): Boolean {
    return when(x) {
        in listOf(1, 2, 3, 4, 5, 6) -> true
        else -> false
    }
}

fun startsWithFoo(any: Any): Boolean {
    return when(any) {
        is String -> any.startsWith("Foo")
        else -> false
    }
}

fun compareNumbers(x: Int, y: Int) {
    when {
        x < y -> println("$x is less than $y")
        x > y -> println("$x is greater than $y")
        else -> println("$x must equal $y")
    }
}

fun largestNumber(a: Int, b: Int, c: Int): Int {
    fun largest(a: Int, b: Int): Int {
        if (a > b) return a
        else return b
    }
    return largest(largest(a, b), largest(b, c))
}

fun printLessThanTwo() {
    val list = listOf(1, 2, 3, 4)
    list.forEach(fun(x) {
        if (x < 2) println(x)
        else return
    })
    println("This line will still execute")
}

fun printUntilStop() {
    val list = listOf("a", "b", "stop", "c")
    list.forEach stop@ {
        if (it == "stop") return@stop
        else println(it)
    }
}

fun main(args: Array<String>) {
    println(App().greeting)

    val name = "Sam"
    val concat = "Hello $name"
    println(concat)

    val str = "Hi $name. Your name has ${name.length} characters"
    println(str)

    val aToZ = "a".."z"
//    val oneToNine = 1..9

//    val countingDown = 100.downTo(0)
//    val rangeTo = 10.rangeTo(20)

//    val oneToFifty = 1..50
//    val oddNumbers = oneToFifty.step(2)

    val countingDownEvenNumbers = (2..100).step(2).reversed()

    val list = listOf(1, 2, 3, 4)

    val string = "print my characters"

    val perfectSquares = Array(10, { k -> k * k })

    for (k in perfectSquares) {
        print("$k ")
    }

    val array = arrayOf(1, 2, 3)
    for (index in array.indices) {
        println("Element $index is ${array[index]}")
    }

    // Exception handling
    val currentDir = Paths.get(".")
    println(currentDir.toAbsolutePath())
    readFile(Paths.get("test.txt"))

    // if..else as expression
    val date = Date()
    val year20 = if (date.year == 2020) true else false
    println("Is year 2020? : $year20")

    // try..catch as expression
    val success = try {
//        readExceptionalFile()
        readMediocreFile()
        true
    } catch (e: IOException) {
        false
    }
    println("Reading file, a ${if (success) "success" else "failure"}")

    // the null syntax
    val nstr: String? = null
    println("Is 'string' a string yet? : ${isString(string)}")

    // smart casts
    printStringLength(string)
    println("Is Empty String: ${isEmptyString(string)}")
    println("Is Not String Or Empty: ${isNotStringOrEmpty("test")}")

    // explicit casting
    val any = "/home/users/nix"
    val path: String? = any as? String
    val file: File? = any as? File
    println("path: $path, file: $file")

    // when
    whatBinaryDigit(0)
    whatBinaryDigit(1)
    
    // when as expression
    println("Is 0 binary? : ${isBinary(0)}")
    println("Is 1 binary? : ${isBinary(1)}")
    println("Is 2 binary? : ${isBinary(2)}")

    // when not limited to matching constants
    println("Is 3 absolute? : ${isAbs(3)}")

    // when with ranges
    println("Is -4 single digit: ${isSingleDigit(-4)}")
    println("Is 14 single digit: ${isSingleDigit(14)}")

    // when with list
    println("Is 5 a die number: ${isDieNumber(5)}")
    println("Is 7 a die number: ${isDieNumber(7)}")

    // when with smart cast
    println("FooFighters starts with 'Foo'? : ${startsWithFoo("FooFighters")}")
    println("Nevermind starts with 'Foo'? : ${startsWithFoo("Nevermind")}")

    // when subject in variable, since Kotlin 1.3
    val httpOk = 201
    val httpErr = 403
    val httpUnknown = 601
    when (val statusCode = httpUnknown) {
        in 200..204 -> println("Success: $statusCode")
        in 400..451 -> println("Client Error: $statusCode")
        else -> println("Unknown HTTP status code")
    }

    // when without arguments
    compareNumbers(21, 42)
    compareNumbers(21, 4)
    compareNumbers(21, 21)

    // 'return' returns from the nearest enclosing function or anonymous function
    println("Largest number in (32, 91, 8) is: ${largestNumber(32, 91, 8)}") 
    printLessThanTwo()

    // return with label
    printUntilStop()
}
